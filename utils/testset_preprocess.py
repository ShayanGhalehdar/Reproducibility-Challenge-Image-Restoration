# -*- coding: utf-8 -*-
"""testset_preprocess.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ENQR1kBmttBpeYObPifrltdTimB_hDCh
"""

import torch
import torch.nn as nn
import torch.nn.functional as F
from google.colab import drive
import os
import cv2
import numpy as np
from PIL import Image
import torchvision.transforms as transforms

print("GPU Available:", torch.cuda.is_available())

# Print GPU details
if torch.cuda.is_available():
    print("GPU Name:", torch.cuda.get_device_name(0))

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

drive.mount('/content/drive')
test_input_lmdb_folder = '/content/drive/My Drive/test/input.lmdb/'
test_target_lmdb_folder = '/content/drive/My Drive/test/target.lmdb/'

test_input_images_folder = "test_input_images"
os.makedirs(test_input_images_folder, exist_ok=True)

test_target_images_folder = "test_target_images"
os.makedirs(test_target_images_folder, exist_ok=True)

test_input_patches_folder = "test_input_patches"
os.makedirs(test_input_patches_folder, exist_ok=True)

test_target_patches_folder = "test_target_patches"
os.makedirs(test_target_patches_folder, exist_ok=True)

!pip install lmdb

import lmdb
import cv2
import numpy as np
import os

def extract_images_from_lmdb(lmdb_folder, output_folder):
    """
    Extracts PNG images from an LMDB database and saves them to the specified folder.

    Args:
        lmdb_folder (str): Path to the LMDB folder containing data.mdb and lock.mdb.
        output_folder (str): Path to the folder where extracted images will be saved.
    """
    # Open LMDB environment
    env = lmdb.open(lmdb_folder, readonly=True, lock=False)

    with env.begin() as txn:
        cursor = txn.cursor()
        for key, value in cursor:
            # Decode the key (filename)
            filename = key.decode("utf-8")

            # Ensure filename has .png extension
            if not filename.endswith(".png"):
                filename += ".png"

            # Convert value (image data) to numpy array
            img_array = np.frombuffer(value, dtype=np.uint8)
            img = cv2.imdecode(img_array, cv2.IMREAD_UNCHANGED)  # Read as an image

            if img is None:
                print(f"Warning: Could not decode image for key {filename}, skipping...")
                continue  # Skip if decoding fails

            # Ensure output folder exists
            os.makedirs(output_folder, exist_ok=True)

            # Save the image
            output_path = os.path.join(output_folder, filename)
            cv2.imwrite(output_path, img)
            print(f"Saved {output_path}")

    print("Extraction complete!")

# patcher function

def compute_stride(image_size, patch_size):
    """
    Compute the optimal stride to ensure full coverage while maximizing uniform patches.
    """
    num_patches = (image_size + patch_size - 1) // patch_size  # Equivalent to math.ceil
    return (image_size - patch_size) // (num_patches - 1) if num_patches > 1 else 1

def extract_patches(image, patch_size=256):
    """
    Extracts patches ensuring full coverage.
    """
    _, h, w = image.shape
    stride_h = compute_stride(h, patch_size)
    stride_w = compute_stride(w, patch_size)

    # Generate patch indices efficiently
    i_vals = torch.arange(0, h - patch_size + 1, stride_h)
    j_vals = torch.arange(0, w - patch_size + 1, stride_w)

    # Compute number of patches
    num_patches_h = i_vals.shape[0]
    num_patches_w = j_vals.shape[0]

    # Preallocate tensor for patches
    patches = torch.empty((num_patches_h * num_patches_w, 3, patch_size, patch_size), dtype=image.dtype, device=image.device)

    indices = []
    patch_idx = 0
    for i in i_vals:
        for j in j_vals:
            patches[patch_idx] = image[:, i:i+patch_size, j:j+patch_size]
            indices.append((i.item(), j.item()))
            patch_idx += 1

    return patches, indices, stride_h, stride_w

import os
from PIL import Image
import torch
from torchvision import transforms

def save_patches(image_folder, patch_folder, prefix):
    """
    Extracts patches from images in image_folder and saves them in patch_folder.

    Args:
        image_folder (str): Path to the folder containing images.
        patch_folder (str): Path to save patches.
        prefix (str): Prefix for naming output patches.
    """
    os.makedirs(patch_folder, exist_ok=True)  # Ensure output folder exists
    transform = transforms.ToTensor()
    image_counter = 0

    # Get sorted list of PNG files
    img_files = sorted([f for f in os.listdir(image_folder) if f.endswith('.png')])

    for img_file in img_files:
        img_path = os.path.join(image_folder, img_file)

        # Load and preprocess image
        with Image.open(img_path) as img:
            img = img.convert("RGB")
            image_tensor = transform(img)  # Convert to tensor (C, H, W)

        # Extract patches
        patches, _, _, _ = extract_patches(image_tensor, patch_size=256)

        # Save patches efficiently
        for idx, patch in enumerate(patches):
            patch_name = f"{prefix}_{image_counter:05d}_{idx:03d}.png"
            patch_path = os.path.join(patch_folder, patch_name)
            transforms.ToPILImage()(patch).save(patch_path)

        image_counter += 1

        # Print progress every 100 images
        if image_counter % 100 == 0:
            print(f"Processed {image_counter} {prefix} images...")

    print(f"Finished processing {image_counter} {prefix} images.")

extract_images_from_lmdb(test_input_lmdb_folder, test_input_images_folder)
extract_images_from_lmdb(test_target_lmdb_folder, test_target_images_folder)

save_patches(test_input_images_folder, test_input_patches_folder, 'input')
save_patches(test_target_images_folder, test_target_patches_folder, 'target')

# visualize 15 instances from test_input_patches_folder in a 3 by 5 grid

import matplotlib.pyplot as plt
import os

# Assuming test_input_patches_folder is defined as in the previous code

def visualize_patches(folder_path, num_patches=15, cols=5):
    """Visualizes a specified number of image patches in a grid."""

    rows = (num_patches + cols - 1) // cols  # Calculate rows needed
    fig, axes = plt.subplots(rows, cols, figsize=(15, 3 * rows))  # Adjust figsize for more rows
    image_files = sorted([f for f in os.listdir(folder_path) if f.endswith('.png')])
    for i in range(min(num_patches, len(image_files))):
      row = i // cols
      col = i % cols
      img = plt.imread(os.path.join(folder_path, image_files[i]))
      axes[row, col].imshow(img)
      axes[row, col].axis('off')  # Hide axes
    # Hide empty subplots if num_patches is not a multiple of cols
    for i in range(num_patches, rows * cols):
      row = i // cols
      col = i % cols
      axes[row, col].axis('off')

    plt.tight_layout()
    plt.show()

visualize_patches(test_input_patches_folder, num_patches=15, cols=5)

# prompt: zip test_input_patches_folder and test_target_patches_folder seperately and save

import shutil
import os

def zip_folder(folder_path, output_filename):
    """Zips a folder and its contents."""
    shutil.make_archive(output_filename, 'zip', folder_path)
    print(f"Folder '{folder_path}' zipped to '{output_filename}.zip'")

# Zip the folders
zip_folder("test_input_patches", "test_input_patches")
zip_folder("test_target_patches", "test_target_patches")